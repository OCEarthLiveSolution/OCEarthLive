'''
Created on Apr 21, 2016

@author: neil
'''
import json
from osgeo import ogr
from database import DBTweets, DBSession


class TweetConsumer(object):
    '''
    Consumes the results of a Twitter search.  To use this class, create a
    subclass and implement the _save() method.
    '''
    # Hashtag and geometries table.
    __hashtag_table = {}
    
    # Counters, so we can gauge if it's working.
    title_matches = 0
    geo_enabled_matches = 0
    geo_matches = 0
    
    def __in_polygons(self, point):
        '''Determines if the point is in one of the polygons or near a point.'''
        for geometries in self.__hashtag_table.values():
            for geometry in geometries:
                if 'POLYGON' == geometry.GetGeometryName():
                    if point.Within(geometry):
                        return True
        return False
        
    
    def __filter(self, tweet):
        '''
        Checks for the presence of geodata and if the coordinates are near
        the EONet event.  If yes to both, then returns True.
        '''
        self.title_matches += 1
        retval = False
        if tweet.coordinates is not None:
            self.geo_enabled_matches += 1
            geojson_point = json.dumps(tweet.coordinates)
            point = ogr.CreateGeometryFromJson(geojson_point)
            retval = self.__in_polygons(point)
            
        if retval:
            self.geo_matches += 1

#       return retval
        return True
    
    # The geometries can be either OGR Points or OGR Polygons.  At this point
    # in the execution the geometries are turned into these objects, so that
    # it's done just one rather than for every tweet.
    #
    # The structure looks like this:
    # {
    #  hastag1: [(type, geometry), ...],
    #  ...
    # }
    def set_search_table(self, tbl):
        '''Builds the table of hashtags and geometries.'''
        for hashtag, geometries in tbl.items():
            ogr_geoms = []
            for geometry in geometries:
                geo_json = json.dumps(geometry)
                ogr_geom = ogr.CreateGeometryFromJson(geo_json)
                ogr_geoms.append(ogr_geom)
            self.__hashtag_table[hashtag] = ogr_geoms
        
    def reset_counters(self):
        '''Sets the number of title and geo matches to zero.'''
        self.title_matches = 0
        self.geo_matches = 0
        self.geo_enabled_matches = 0
    
    def process(self, tweets):
        '''
        Iterate through the tweets, filtering out the relevant ones and then
        send them to a save method.
        '''
        for tweet in tweets:
            if self.__filter(tweet):
                self._save(tweet)
        
        
# This class is useful for initial development and detailed debugging.
class RawDump(TweetConsumer):
    '''Dumps the tweet, in raw json, to standard out.'''
    def _save(self, tweets):
        for tweet in tweets:
            print tweet


# This class presents refined output to standard out.  It's useful for
# high-level troubleshooting. 
class PrettyDump(TweetConsumer):
        '''
        Presents the most interesting parts of a tweet in formatted text to
        standard out.
        '''
        def _save(self, tweet):
            msg = tweet.text.encode('utf8', 'replace')
            name = tweet.user.name.encode('utf8', 'replace')
            msg_date = tweet.created_at
            if tweet.place is not None:
                place = tweet.place.name.encode('utf8', 'replace')
            else:
                place = 'Unknown'
            print('Written to the database.  [Name: %s][Place: %s][At: %s] %s' %
                  (name, place, msg_date, msg))


# This class saves the tweets to a Sqlite database.
class SQLDump(TweetConsumer):
    '''
    Saves the parts of the tweet that the REST API requires to a database.
    '''
    def __init__(self):
        self.__session = DBSession().session

    def _save(self, tweet):
        # the data fields to save.
        name = tweet.user.name
        create_date = tweet.created_at
        place = tweet.place.name if tweet.place else None
        text = tweet.text
            
        # Commit to the database.
        tweet_record = DBTweets(name=name,
                                createDate=create_date,
                                place=place,
                                text=text)
        
        # Write the same to standard out to monitor the progress.  The terminal
        # requires the text to be encoded as utf8.
        text = text.encode('utf8', 'replace')
        name = name.encode('utf8', 'replace')
        place = place.encode('utf8', 'replace') if place else None
        print('Saved to the database: (Name: %s)(Place: %s)(At: %s) %s.' %
              (name, place, create_date, text))
        
        self.session.add(tweet_record)
        self.session.commit()