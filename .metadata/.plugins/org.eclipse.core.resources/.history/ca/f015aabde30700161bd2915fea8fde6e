'''
Created on Apr 21, 2016

@author: neil
'''
import json
import tweepy
from osgeo import ogr
from config import (ACCESS_TOKEN, ACCESS_TOKEN_SECRET,
                    CONSUMER_KEY, CONSUMER_SECRET)
from config import MAX_SEARCH_TWEETS


QUERY_STRING = 'flooding in houston texas'
QUERY_POLYGON = '''{
                    "date": "2016-04-17T00:00:00Z",
                    "type": "Polygon", 
                    "coordinates": [[ [-95.980224609375, 29.213727993972313], [-95.980224609375, 30.36072451862922], [-94.64599609375, 30.36072451862922], [-94.64599609375, 29.213727993972313], [-95.980224609375, 29.213727993972313] ]]
                }'''


class TweetFetcher(object):
    
    consumer = None
    
    __max_tweets = MAX_SEARCH_TWEETS
    
    
    def __init__(self, api):
        self.__api = api
        
    def fetch(self):
        # The consumer has the search string.
        query = self.consumer.query
        
        # Execute the search and page through the results. 
        last_id = -1
        count = 0
        while count < self.__max_tweets:
    
            try:
                new_tweets = self.__api.search(q=query, count=count, max_id=str(last_id - 1))
                if not new_tweets:
                    break
                count += len(new_tweets)
                self.consumer.process(new_tweets)
                
                last_id = new_tweets[-1].id
            except tweepy.TweepError as e:
                # depending on TweepError.code, one may want to retry or wait
                # to keep things simple, we will give up on an error
                print e
                break        


class TweetConsumer(object):
    '''
    Consumes the results of a Twitter search.  To use this class, create a
    subclass and implement the _save() method.
    '''
    __polygon = None
    
    def __filter(self, tweet):
        '''
        Checks for the presence of geodata and if the coordinates are near
        the EONet event.  If yes to both, then ...
        '''
        retval = False
        if tweet.coordinates is not None:
            geojson_point = json.dumps(tweet.coordinates)
            point = ogr.CreateGeometryFromJson(geojson_point)
            retval = point.Within(self.__polygon)
        return retval
    
    # The polygon needs to be of type POLYGON.  It's a property of the search
    # that's calculated once, before the search, to avoid making this
    # calculation with every tweet.
    def set_polygon(self, poly):
        '''Sets the polygon to use in the search filter.'''
        self.__polygon = ogr.CreateGeometryFromJson(poly)
    
    def process(self, tweets):
        '''
        Iterate through the tweets, filtering out the relevant ones and then
        send them to a save method.'''
        for tweet in tweets:
            if self.__filter(tweet):
                self._save(tweet)
        
        
# This class is useful for initial development and detailed debugging.
class RawDump(TweetConsumer):
    '''Dumps the tweet, in raw json, to standard out.'''
    def _save(self, tweets):
        for tweet in tweets:
            print tweet


# This class presents refined output to standard out.  It's useful for
# high-level troubleshooting. 
class PrettyDump(TweetConsumer):
        '''
        Presents the most interesting parts of a tweet in formatted text to
        standard out.
        '''
        def _save(self, tweet):
            coords = geodata(tweet)
            if coords is not None:
                msg = tweet.text.encode('utf8', 'replace')
                name = tweet.user.name.encode('utf8', 'replace')
                geo_enabled = tweet.user.geo_enabled
                print('%s [Geoenabled: %s]: %s' % (name, geo_enabled, msg))


def geodata(tweet):
    '''Provides the latitude and longitude of the tweet if present.'''
    coords = None
    if tweet.coordinates is not None:
        coords = tweet.coordinates['coordinates']
    return coords

def search_tweets():
    
    auth = tweepy.OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)
    auth.set_access_token(ACCESS_TOKEN, ACCESS_TOKEN_SECRET)
    
    api = tweepy.API(auth)
    tweetfetcher = TweetFetcher(api)
    consumer = PrettyDump()
    tweetfetcher.consumer = consumer
    
    # Loop through the events in EONet.
    consumer.query = QUERY_STRING
    consumer.set_polygon(QUERY_POLYGON)
    tweetfetcher.fetch()
    
